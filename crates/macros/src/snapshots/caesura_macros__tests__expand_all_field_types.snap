---
source: crates/macros/src/lib.rs
expression: output
---
/// Partial options struct with optional fields for CLI/YAML parsing.
#[derive(
    ::clap::Args,
    ::std::clone::Clone,
    ::std::fmt::Debug,
    ::std::default::Default,
    ::serde::Deserialize,
    ::serde::Serialize
)]
pub struct TestOptionsPartial {
    /// non-Option, no defaults
    #[arg(long = "a")]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub a: Option<String>,
    /// non-Option, static default
    ///
    /// Default: `42`
    #[arg(long = "b")]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub b: Option<u32>,
    /// non-Option, default_fn with doc
    ///
    /// Default: `computed at runtime`
    #[arg(long = "c")]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub c: Option<u32>,
    /// non-Option, both
    ///
    /// Default: `99`
    #[arg(long = "d")]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub d: Option<u32>,
    /// Option, no defaults
    #[arg(long = "e")]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub e: Option<String>,
    /// Option, static default
    ///
    /// Default: `Some("fallback" . to_owned())`
    #[arg(long = "f")]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub f: Option<String>,
    /// Option, default_fn
    #[arg(long = "g")]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub g: Option<String>,
    /// Option, both
    ///
    /// Default: `Some("final" . to_owned())`
    #[arg(long = "h")]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub h: Option<String>,
}
impl TestOptionsPartial {
    fn resolve_internal(
        mut self,
        validate: bool,
    ) -> ::std::result::Result<
        TestOptions,
        ::std::vec::Vec<crate::options::OptionRule>,
    > {
        let mut errors = ::std::vec::Vec::new();
        let defaults = self.clone();
        let a = self.a;
        let b = self.b;
        let c = self.c.or_else(|| compute_c(&defaults));
        let d = self.d.or_else(|| compute_d(&defaults));
        let e = self.e;
        let f = self.f;
        let g = self.g.or_else(|| compute_g(&defaults));
        let h = self.h.or_else(|| compute_h(&defaults));
        let resolved = TestOptions {
            a: a.unwrap_or_default(),
            b: b.unwrap_or_else(|| 42),
            c: c.unwrap_or_default(),
            d: d.unwrap_or_else(|| 99),
            e,
            f: f.or_else(|| Some("fallback".to_owned())),
            g,
            h: h.or_else(|| Some("final".to_owned())),
        };
        if validate {
            resolved.validate(&mut errors);
        }
        if errors.is_empty() {
            ::std::result::Result::Ok(resolved)
        } else {
            ::std::result::Result::Err(errors)
        }
    }
}
impl crate::options::OptionsPartialContract for TestOptionsPartial {
    type Resolved = TestOptions;
    fn merge(&mut self, other: Self) {
        if self.a.is_none() {
            self.a = other.a;
        }
        if self.b.is_none() {
            self.b = other.b;
        }
        if self.c.is_none() {
            self.c = other.c;
        }
        if self.d.is_none() {
            self.d = other.d;
        }
        if self.e.is_none() {
            self.e = other.e;
        }
        if self.f.is_none() {
            self.f = other.f;
        }
        if self.g.is_none() {
            self.g = other.g;
        }
        if self.h.is_none() {
            self.h = other.h;
        }
    }
    fn resolve_without_validation(self) -> TestOptions {
        self.resolve_internal(false).expect("validation disabled")
    }
    fn resolve(
        self,
    ) -> ::std::result::Result<
        TestOptions,
        ::std::vec::Vec<crate::options::OptionRule>,
    > {
        self.resolve_internal(true)
    }
}
impl ::std::default::Default for TestOptions {
    fn default() -> Self {
        Self {
            a: ::std::default::Default::default(),
            b: 42,
            c: ::std::default::Default::default(),
            d: 99,
            e: ::std::option::Option::None,
            f: ::std::option::Option::None,
            g: ::std::option::Option::None,
            h: ::std::option::Option::None,
        }
    }
}
impl crate::options::Documented for TestOptions {
    fn doc_metadata() -> &'static crate::options::OptionsDoc {
        static DOC: ::std::sync::LazyLock<crate::options::OptionsDoc> = ::std::sync::LazyLock::new(||
        crate::options::OptionsDoc {
            name: "TestOptions",
            description: "",
            fields: ::std::vec![
                crate ::options::FieldDoc { config_key : "a", cli_flag : "--a",
                field_type : "String", default_value :
                ::std::option::Option::Some(::serde_json::to_string(& < String >
                ::default()).unwrap()), default_doc : ::std::option::Option::None,
                description : "non-Option, no defaults", }, crate ::options::FieldDoc {
                config_key : "b", cli_flag : "--b", field_type : "u32", default_value :
                ::std::option::Option::Some(::serde_json::to_string(& (42)).unwrap()),
                default_doc : ::std::option::Option::None, description :
                "non-Option, static default", }, crate ::options::FieldDoc { config_key :
                "c", cli_flag : "--c", field_type : "u32", default_value :
                ::std::option::Option::Some(::serde_json::to_string(& < u32 >
                ::default()).unwrap()), default_doc :
                ::std::option::Option::Some("computed at runtime"), description :
                "non-Option, default_fn with doc", }, crate ::options::FieldDoc {
                config_key : "d", cli_flag : "--d", field_type : "u32", default_value :
                ::std::option::Option::Some(::serde_json::to_string(& (99)).unwrap()),
                default_doc : ::std::option::Option::None, description :
                "non-Option, both", }, crate ::options::FieldDoc { config_key : "e",
                cli_flag : "--e", field_type : "Option<String>", default_value :
                ::std::option::Option::None, default_doc : ::std::option::Option::None,
                description : "Option, no defaults", }, crate ::options::FieldDoc {
                config_key : "f", cli_flag : "--f", field_type : "Option<String>",
                default_value : ::std::option::Option::Some(::serde_json::to_string(&
                (Some("fallback".to_owned()))).unwrap()), default_doc :
                ::std::option::Option::None, description : "Option, static default", },
                crate ::options::FieldDoc { config_key : "g", cli_flag : "--g",
                field_type : "Option<String>", default_value :
                ::std::option::Option::None, default_doc : ::std::option::Option::None,
                description : "Option, default_fn", }, crate ::options::FieldDoc {
                config_key : "h", cli_flag : "--h", field_type : "Option<String>",
                default_value : ::std::option::Option::Some(::serde_json::to_string(&
                (Some("final".to_owned()))).unwrap()), default_doc :
                ::std::option::Option::None, description : "Option, both", }
            ],
        });
        &DOC
    }
}
